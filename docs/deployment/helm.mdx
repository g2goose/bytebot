---
title: "Helm Deployment"
description: "Deploy Bytebot on Kubernetes using Helm charts"
---

# Deploy Bytebot on Kubernetes with Helm

Helm provides a simple way to deploy Bytebot on Kubernetes clusters.

## Prerequisites

- Kubernetes cluster (1.19+)
- Helm 3.x installed
- kubectl configured
- 8GB+ available memory in cluster

## Quick Start

<Steps>
  <Step title="Clone Repository">
    ```bash
    git clone https://github.com/bytebot-ai/bytebot.git
    cd bytebot
    ```
  </Step>
  
  <Step title="Configure API Keys">
    Create a `values.yaml` file with at least one API key:
    
    ```yaml
    bytebot-agent:
      apiKeys:
        anthropic:
          value: "sk-ant-your-key-here"
        # Optional: Add more providers
        # openai:
        #   value: "sk-your-key-here"
        # gemini:
        #   value: "your-key-here"
    ```
  </Step>
  
  <Step title="Install Bytebot">
    ```bash
    helm install bytebot ./helm \
      --namespace bytebot \
      --create-namespace \
      -f values.yaml
    ```
  </Step>
  
  <Step title="Access Bytebot">
    ```bash
    # Port-forward for local access
    kubectl port-forward -n bytebot svc/bytebot-ui 9992:9992
    
    # Access at http://localhost:9992
    ```
  </Step>
</Steps>

## Basic Configuration

### API Keys

Configure at least one AI provider:

```yaml
bytebot-agent:
  apiKeys:
    anthropic:
      value: "sk-ant-your-key-here"
    openai:
      value: "sk-your-key-here"
    gemini:
      value: "your-key-here"
```

### Resource Limits (Optional)

Adjust resources based on your needs:

```yaml
# Desktop container (where automation runs)
desktop:
  resources:
    requests:
      memory: "2Gi"
      cpu: "1"
    limits:
      memory: "4Gi"
      cpu: "2"

# Agent (AI orchestration)
agent:
  resources:
    requests:
      memory: "1Gi"
      cpu: "500m"
```

### External Access (Optional)

Enable ingress for domain-based access:

```yaml
ui:
  ingress:
    enabled: true
    hostname: bytebot.your-domain.com
    tls: true
```

## Accessing Bytebot

### Local Access (Recommended)

```bash
kubectl port-forward -n bytebot svc/bytebot-ui 9992:9992
```

Access at: http://localhost:9992

### External Access

If you configured ingress:
- Access at: https://bytebot.your-domain.com

## Verifying Deployment

Check that all pods are running:

```bash
kubectl get pods -n bytebot
```

Expected output:
```
NAME                              READY   STATUS      RESTARTS   AGE
bytebot-agent-xxxxx               1/1     Running     0          2m
bytebot-agent-xxxxx-migrations    0/1     Completed   0          2m
bytebot-desktop-xxxxx             1/1     Running     0          2m
bytebot-postgresql-0              1/1     Running     0          2m
bytebot-ui-xxxxx                  1/1     Running     0          2m
```

<Note>
  The `bytebot-agent-xxxxx-migrations` init container runs Prisma database migrations before the agent starts. It should show `Completed` status.
</Note>

## Database Migrations

Bytebot uses Prisma for database schema management. Migrations are handled automatically via Kubernetes init containers:

### How Migrations Work

1. **Init Container Runs First**: Before the agent pod starts, a migration init container executes
2. **Schema Updates Applied**: Prisma migrations are applied to the PostgreSQL database
3. **Agent Starts**: Only after successful migrations, the main agent container starts

### Viewing Migration Status

```bash
# Check init container status
kubectl get pods -n bytebot -l app.kubernetes.io/name=bytebot-agent

# View migration logs
kubectl logs -n bytebot <bytebot-agent-pod> -c migrations

# If migrations fail, the pod will remain in Init:0/1 state
```

### Migration Failures

If the init container fails:

```bash
# Get detailed error information
kubectl describe pod -n bytebot <bytebot-agent-pod>
kubectl logs -n bytebot <bytebot-agent-pod> -c migrations

# Common issues:
# - Database connection failed (check DATABASE_URL)
# - Schema conflicts (manual intervention needed)
# - Permission errors (check database user permissions)
```

<Warning>
  The agent container **cannot** run migrations at runtime. This is a security feature of the distroless deployment - the application has no migration tooling available.
</Warning>

### Manual Migration Rollback

If you need to rollback migrations:

```bash
# Scale down the agent deployment
kubectl scale deployment -n bytebot bytebot-agent --replicas=0

# Connect to PostgreSQL pod
kubectl exec -it -n bytebot bytebot-postgresql-0 -- psql -U postgres

# Manually restore database or drop schema
# Then redeploy with correct migration state
```

## Troubleshooting

### Pods Not Starting

Check pod status:
```bash
kubectl describe pod -n bytebot <pod-name>
```

Common issues:
- Insufficient memory/CPU: Check node resources with `kubectl top nodes`
- Missing API keys: Verify your values.yaml configuration

### Connection Issues

Test service connectivity:
```bash
kubectl logs -n bytebot deployment/bytebot-agent
```

### View Logs

```bash
# All logs
kubectl logs -n bytebot -l app=bytebot --tail=100

# Specific component
kubectl logs -n bytebot deployment/bytebot-agent
```

## Upgrading

```bash
# Update your values.yaml as needed, then:
helm upgrade bytebot ./helm -n bytebot -f values.yaml
```

## Uninstalling

```bash
# Remove Bytebot
helm uninstall bytebot -n bytebot

# Clean up namespace
kubectl delete namespace bytebot
```

## Advanced Configuration

<AccordionGroup>
  <Accordion title="Using External Secrets">
    If using Kubernetes secret management (Vault, Sealed Secrets, etc.):
    
    ```yaml
    bytebot-agent:
      apiKeys:
        anthropic:
          useExisting: true
          secretName: "my-api-keys"
          secretKey: "anthropic-key"
    ```
    
    Create the secret manually:
    ```bash
    kubectl create secret generic my-api-keys \
      --namespace bytebot \
      --from-literal=anthropic-key="sk-ant-your-key"
    ```
  </Accordion>
  
  <Accordion title="LiteLLM Proxy Mode">
    For centralized LLM management, use the included LiteLLM proxy:
    
    ```bash
    helm install bytebot ./helm \
      -f values-proxy.yaml \
      --namespace bytebot \
      --create-namespace \
      --set bytebot-llm-proxy.env.ANTHROPIC_API_KEY="your-key"
    ```
    
    This provides:
    - Centralized API key management
    - Request routing and load balancing
    - Rate limiting and retry logic
  </Accordion>
  
  <Accordion title="Custom Storage">
    Configure persistent storage:
    
    ```yaml
    desktop:
      persistence:
        enabled: true
        size: "20Gi"
        storageClass: "fast-ssd"
    
    postgresql:
      persistence:
        size: "20Gi"
        storageClass: "fast-ssd"
    ```
  </Accordion>
  
  <Accordion title="Production Security">
    ```yaml
    # Network policies
    networkPolicy:
      enabled: true

    # Pod security
    podSecurityContext:
      runAsNonRoot: true
      runAsUser: 1000
      fsGroup: 1000

    # Enable authentication
    auth:
      enabled: true
      type: "basic"
      username: "admin"
      password: "changeme"  # Use secrets in production!
    ```
  </Accordion>

  <Accordion title="Distroless Security">
    All Bytebot application services use Google's [distroless](https://github.com/GoogleContainerTools/distroless) container images for enhanced security:

    **Security Features:**
    - **No Shell Access**: Images contain only the application and runtime
    - **Non-Root Execution**: All services run as UID 65532 (nonroot user)
    - **Minimal Attack Surface**: No package managers or unnecessary binaries
    - **Reduced CVEs**: Fewer packages means fewer vulnerabilities

    **Operational Implications:**

    ```bash
    # You CANNOT exec into containers with a shell
    kubectl exec -it bytebot-agent -- sh  # ❌ Will fail

    # Instead, use these debugging methods:

    # 1. View logs
    kubectl logs -f bytebot-agent

    # 2. Describe pod
    kubectl describe pod bytebot-agent

    # 3. Use a debug container (Kubernetes 1.23+)
    kubectl debug -it bytebot-agent --image=busybox --target=bytebot-agent

    # 4. Check running processes
    kubectl exec bytebot-agent -- ps aux  # ❌ Will fail (no ps)
    # Use kubectl top instead:
    kubectl top pod bytebot-agent
    ```

    **Health Checks:**

    Distroless images don't include health check utilities. Configure Kubernetes probes:

    ```yaml
    bytebot-agent:
      livenessProbe:
        httpGet:
          path: /health
          port: 9991
        initialDelaySeconds: 30
        periodSeconds: 10

      readinessProbe:
        httpGet:
          path: /health
          port: 9991
        initialDelaySeconds: 5
        periodSeconds: 5
    ```

    **Benefits:**
    - 25-35% smaller image sizes
    - Faster deployments
    - Reduced attack surface
    - Production-ready security posture

    For detailed debugging guidance, see [distroless troubleshooting](/deployment/distroless-troubleshooting).
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="API Reference" icon="code" href="/api-reference/introduction">
    Integrate Bytebot with your applications
  </Card>
  <Card title="LiteLLM Integration" icon="plug" href="/deployment/litellm">
    Use any LLM provider with Bytebot
  </Card>
</CardGroup>

<Note>
  **Need help?** Join our [Discord community](https://discord.com/invite/d9ewZkWPTP) or check our [GitHub discussions](https://github.com/bytebot-ai/bytebot/discussions).
</Note>